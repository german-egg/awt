#!/bin/bash

set -euo pipefail

version="20230320"

file="CHANGELOG.md"
sp="   "
firm="Power by [awt script](https://github.com/galiprandi/awt)."
date=$(date '+%Y-%m-%d_%H:%M:%S')
color='\033[1;93m'
cm='\033[1;34m'
red='\033[1;31m'
user_name=$(git config --get user.name)
user_email=$(git config --get user.email)
line="â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
line_up="â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®"
line_dw="â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯"
no_title="Untitled task"
un_released="## UnReleased"
last_tag=$(git describe --tags --always)
current_branch=$(git rev-parse --abbrev-ref HEAD)
default_branch_source="develop"
dev_tracking_app="Jira"
dev_tracking_app_ticket_link="https://eggcooperation.atlassian.net/browse"

nc='\033[0m'

# Show AWT version
display_version() {
    echo -e "v$version"
    exit 0
}

# Get option from command line
while getopts s:v opt; do
    case "${opt}" in
    s) default_branch_source=${OPTARG} ;;
    v) display_version ;;
    esac
done

# =============== UTILITY FUNCTIONS ===============

# Get lasted version
get_latest_version() {
    local url="https://raw.githubusercontent.com/galiprandi/awt/egg/awt"
    echo ""
    curl -O "$url"
    echo ""
    echo "Done"
    exit 0
}

# Add new UnReleased line to changelog
add_un_released_entry_to_changelog() {
    new_entry="$un_released\n\n$1"
    file_tmp="$file.tmp"
    echo "$1" >./$file_tmp && cat $file >>$file_tmp && mv $file_tmp $file
}

# Return tickets ID diff between two branches
get_tickets_id_diff() {
    echo -e ""
    echo -e "${color}Ticket ID diff between $1 and $2: ${nc}"
    echo -e ""
    source=$(select_branch "Select source branch")
    target=$(select_branch "Select target branch")
    tickets_diff=($(git log --pretty="format:%s" $target..$source --oneline | grep -o -P '(?<=\| #).*(?=\[)' | grep -v 'none' 2>&1))
    for id in "${tickets_diff[@]}"; do
        echo -e "#$id"
    done
}

# Select branch name
select_branch() {
    options=("develop" "staging" "demo" "main" "master")
    choice_menu "$1" "$options"
}

# Multiple choice menu
choice_menu() {
    options=$2
    echo ""
    PS3=$(echo -e "\n${color}$1: ${nc}")
    select option in "${options[@]}"; do
        if [[ -n $option ]]; then
            echo $option
            break
        fi
    done
}

# Ask for confirmation
confirm() {
    read -p "$sp Do you wish to continue? [y/N]: " confirm

    case "$confirm" in
    [yY][eE][sS] | [yY])
        echo "confirmed"
        ;;
    *)
        echo "aborted"
        ;;
    esac
}

# =============== UTILITY FUNCTIONS ===============

# The wellcom script
wellcome() {
    clear
    echo -e " $sp â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®"
    echo -e " $sp â”‚                                                               â”‚"
    echo -e " $sp â”‚            ðŸ¥š ${color}EGG${nc} Automation Workflow Task                    â”‚"
    echo -e " $sp â”‚                                                               â”‚"
    echo -e " $sp â”‚ v$version                                 by GermÃ¡n Aliprandi â”‚"
    echo -e " $sp â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯"
    echo -e ""
}

# Abort mission
abort() {
    wellcome
    echo ""
    echo -e "$sp You have ${color}aborted${nc} this mission. See ya in the cyberspace !"
    echo ""
    exit 1
}

# New Task: Get type
ct_get_task_type() {
    wellcome
    while true; do
        echo -e "$sp 1) ${color}feat${nc}:     A new feature"
        echo -e "$sp 2) ${color}fix${nc}:      A bug fix"
        echo -e "$sp 3) ${color}docs${nc}:     Documentation only changes"
        echo -e "$sp 4) ${color}style${nc}:    Changes that do not affect the meaning of the code (formatting, semi-colons, etc)"
        echo -e "$sp 5) ${color}refactor${nc}: A code change that neither fixes a bug nor adds a feature"
        echo -e "$sp 6) ${color}perf${nc}:     A code change that improves performance"
        echo -e "$sp 7) ${color}test${nc}:     Adding missing or correcting existing tests"
        echo -e "$sp 8) ${color}chore${nc}:    Changes to the build process or auxiliary tools, libraries or documentation"
        echo -e ""
        echo -e "$sp a) ${color}advanced${nc}: Show advanced options"
        echo -e "$sp x) ${color}exit${nc}:     Exit now !"
        echo ""
        read -p "$sp Choice a task type: " type
        case $type in
        [1]*)
            type="feat"
            break
            ;;
        [2]*)
            type="fix"
            break
            ;;
        [3]*)
            type="docs"
            break
            ;;
        [4]*)
            type="style"
            break
            ;;
        [5]*)
            type="refactor"
            break
            ;;
        [6]*)
            type="perf"
            break
            ;;
        [7]*)
            type="test"
            break
            ;;
        [8]*)
            type="chore"
            break
            ;;
        "a" | "A")
            advanced_menu
            break
            ;;
        "x" | "X")
            abort
            ;;
        *)
            clear
            wellcome
            ;;
        esac
    done
    wellcome
    echo -e "$sp ${color}Creating a new task:${nc}"
    echo -e ""
    echo "$sp- Task type: $type"
}

# New Task: Required Data
ct_get_required_data() {
    # Get ticket ID
    echo ""
    read -p "$sp- $dev_tracking_app ID [none]: " ticket
    ticket=${ticket:-none}
    ticket=${ticket//#/}

    # Get task title
    echo ""
    read -p "$sp- Task title: " title
    title=${title:-$no_title}
    title=${title}

    # Get branch name
    branch_default=${title// /-}
    branch_default=${branch_default}
    echo ""
    read -p "$sp- Branch name [$branch_default]: " branch_name
    branch_name=${branch_name:-$branch_default}
    branch_name=${branch_name// /-}
    branch_name=${branch_name}

    # Create required vars
}

# Copy file from other branch/commit/tag
# $1 branch source
# $2 file path
copy_file_from_branch() {
    git checkout "$1" "$2"
    echo ""
    echo -e "Done."
    echo ""
    exit 0
}

ct_create_vars() {
    mr_desc="[$title]($dev_tracking_app_ticket_link/$ticket)"
    mr_title="$type: $title"
    if [[ $ticket == 'none' ]]; then
        mr_desc=$title
    fi
    branch="$ticket/$type/$branch_name"
    ch_entry="- [**${type}**: $title]($dev_tracking_app_ticket_link/$ticket)"
}

ct_task_summary() {
    clear
    wellcome
    echo -e "$sp ${color}Are you prepared to execute the following tasks?${nc}"
    echo ""
    echo "$sp 1) - Switch to $default_branch_source branch"
    echo "$sp 2) - Pull the latest changes from the $default_branch_source branch"
    echo "$sp 3) - Create a new branch named '$branch'"
    echo "$sp 4) - Add an empty commit as required by $dev_tracking_app"
    echo "$sp 5) - Create a Draft Merge Request from '$branch' with title '$mr_title'"
    echo "$sp 6) - Link $dev_tracking_app ticket with Merge Request and new branch"
    echo "$sp 7) - Update $file with link to the ticket"
    echo ""

    question=$(confirm)
    if [[ $question == "confirmed" ]]; then
        ct_performing_tasks
    else
        abort
    fi
}

ct_performing_tasks() {
    echo ""
    echo -e "${color}Performing operations, wait a moment please...${nc}"
    echo ""

    # Switch to develop, pull, and create a new branch
    git checkout $default_branch_source
    git pull origin $default_branch_source
    git checkout -b $branch
    git push --set-upstream origin $branch

    # Add entry to changelog
    new_entry="- [${type}: $title]($dev_tracking_app_ticket_link/$ticket)"
    add_un_released_entry_to_changelog "$new_entry"
    git add "./$file"
    git commit -m "docs: updating $file for $dev_tracking_app ticket $ticket"
    git push origin $branch

    # Move ticket to Doing status
    git commit --allow-empty -m "chore: $ticket $title" -m "$dev_tracking_app_ticket_link/$ticket"

    # Create MR
    mr_response=$(
        git push \
            -o merge_request.create \
            -o merge_request.draft \
            -o merge_request.remove_source_branch \
            -o merge_request.target="$default_branch_source" \
            -o merge_request.title="$mr_title" \
            -o merge_request.description="$mr_desc $firm" \
            -o merge_request.label="$type" \
            -o merge_request.label="$ticket" \
            2>&1
    )

    # Get URL and open it
    mr_response=$(sed 's/remote://g' <<<"$mr_response")
    mr_response=$(grep 'https://gitlab.com' <<<"$mr_response")
    mr_response=$(sed 's/ *$//g' <<<"$mr_response")

    echo ""
    echo -e "$sp ${color}All operation done !${nc}"
    exit 0
}

main() {
    ct_get_task_type
    ct_get_required_data
    ct_create_vars
    ct_task_summary
}

advanced_menu() {
    wellcome
    while :; do
        echo -e "                      ${color}*** ADVANCED OPTIONS ***${nc}"
        echo -e ""
        echo -e "$sp 1) ${color}Release${nc}: Create a new release"
        echo -e "$sp 2) ${color}Purge local${nc}: Delete all local branches that are not remote"
        echo -e "$sp 3) ${color}Copy file${nc}: Copy file from other branch, commit or tag"
        echo -e ""
        echo -e ""
        echo -e ""
        echo -e "$sp 0) ${color}Back${nc}: to main menu"
        echo -e "$sp u) ${color}Update${nc}: Get latest version of this script"
        echo -e "$sp x) ${color}Exit${nc}:     Exit now !"
        echo -e ""

        adv_option_default="1"
        read -p "$sp Choice a action: [1]: " adv_option
        adv_option=${adv_option:-$adv_option_default}

        case $adv_option in
        [1]*)
            adv_create_release
            break
            ;;
        [2]*)
            adv_purge_local
            break
            ;;
        [3]*)
            adv_copy_file_values "staging" "CHANGELOG.md"
            break
            ;;
        [u]*)
            get_latest_version
            break
            ;;
        [0]*)
            main
            break
            ;;
        "x" | "X")
            abort
            ;;
        *)
            clear
            advanced_menu
            ;;
        esac

    done
}

# Delete orphaned local branches
adv_purge_local() {
    wellcome
    echo -e "$sp ${color}Are you sure that want to purge all local branches?${nc}"
    echo ""
    read -p "$sp Do you wish to continue? [y/N]: " confirm
    case "$confirm" in
    [yY][eE][sS] | [yY])
        git switch develop
        purge_response=$(
            git remote prune origin && git branch -vv | grep ': gone] \: desaparecido]' | awk '{print $1}' | xargs -r git branch -D 2>&1
        )
        # clear
        echo ""
        echo -e "$sp ${color}All local branches deleted !${nc}"
        exit 0
        ;;
    *)
        abort
        ;;
    esac

}

# Create a new release branch
adv_create_release() {
    wellcome
    echo -e "$sp ${color}Create a new release:${nc}"
    adv_cr_get_required_values
    adv_cr_new_tickets_status
    adv_cr_summary
    exit 0
}

# Get all required values for new release
adv_cr_get_required_values() {
    echo ""

    # Get release branch name
    release_default=$(date +v%Y%m%d)
    read -p "$sp - Release name [$release_default]: " release
    release=${release:-$release_default}
    release=${release// /-}
    release=${release,,}

    echo ""

    # Get branch source
    branch_source_default="develop"
    read -p "$sp - Branch source [$branch_source_default]: " branch_source
    branch_source=${branch_source:-$branch_source_default}

    echo ""

    # Get branch target
    branch_target_default="staging"
    read -p "$sp - Branch target [$branch_target_default]: " branch_target
    branch_target=${branch_target:-$branch_target_default}

    echo "-"

    # Get new tickets status
    new_tickets_status_default=""

    case $branch_target in
    "staging")
        new_tickets_status_default="QA"
        ;;
    "demo")
        new_tickets_status_default="DEMO"
        ;;
    "master" | "main")
        new_tickets_status_default="DONE"
        ;;
    esac

    # Get new tickets status
    read -p "$sp - Move ticket to status [$new_tickets_status_default]: " new_tickets_status
    new_tickets_status=${new_tickets_status:-$new_tickets_status_default}
    new_tickets_status=${new_tickets_status^^}

    # Create MR title
    mr_title="Release $release"

}

# Get origin branch & file name to copy
adv_copy_file_values() {
    wellcome
    echo -e "$sp ${color}Copy file from other branch:${nc}"
    echo ""

    read -p "$sp - Copy from branch [$1]:" origin_branch
    origin_branch=${origin_branch:-$1}
    read -p "$sp - Name of file to copy [$2]:" origin_file
    origin_file=${origin_file:-$2}

    copy_file_from_branch "$origin_branch" "$origin_file"
}

adv_cr_update_changelog() {
    if test -f "./$file"; then
        new_lines="$un_released\n\n## Release $release"

        if grep -Fxq "$un_released" $file; then
            sed -i "s/$un_released/$new_lines/i" $file
        else
            sed -i "1s/^/$un_released\n\n/i" $file
        fi
    else
        echo $un_released >"./$file"
    fi

}

adv_cr_new_tickets_status() {
    if test -f "./$file"; then
        tickets="Move tickets to $new_tickets_status: "

        start="$un_released"
        end="## Release"
        un_released_tickets=$(sed -n "/$start/,/$end/{ /$start/! {/$end/! p } }" $file)

        readarray -t un_released_tickets_array <<<"$un_released_tickets"
        html_tickets_list=""
        for item in "${un_released_tickets_array[@]}"; do
            [ ! -z "$item" ] && html_tickets_list="$html_tickets_list<li>${item//'- '/$''}</li>"
        done
        html_tickets_list="<ul>$html_tickets_list</ul>"

        tickets_id=$(sed -e 's/\(^.*\/t\/\)\(.*\)\().*$\)/\2/' <<<"$un_released_tickets")
        task_titles=$(sed -e 's/\(^.*\[\)\(.*\)\(].*$\)/\2/' <<<"$un_released_tickets")
        array_id=($tickets_id)
        array_titles=($task_titles)
        final=""
        i=0
        for ticket in "${array_id[@]}"; do
            tickets="$tickets #$ticket[$new_tickets_status]"
        done
    else
        tickets="No tickets moved, $file not found."
    fi
}

adv_cr_summary() {
    wellcome
    echo -e "$sp ${color}Do you ready to perform this tasks ?${nc}"
    echo -e ""
    echo -e "$sp 1) - Switch to '$branch_source' branch"
    echo -e "$sp 2) - Pull latest '$branch_source' changes"
    echo -e "$sp 3) - Create a release branch '$release' from '$branch_source'"
    echo -e "$sp 4) - Add empty commit *required"
    echo -e "$sp 5) - Create a MR '$mr_title'"
    echo -e "$sp 6) - Add description to new MR with tickets ID and the new status"
    echo -e "$sp 7) - Update and commit $file"
    echo -e "$sp 8) - Push $file to '$release' branch"
    echo -e "$sp 9) - Move tickets to $new_tickets_status"
    echo -e ""

    read -p "$sp Do you wish to continue? [y/N]: " confirm
    case "$confirm" in
    [yY][eE][sS] | [yY])
        adv_cre_performing_task
        ;;
    *)
        abort
        ;;
    esac
}

adv_cre_performing_task() {

    echo ""
    echo -e "$sp${color}Performing operations, wait a moment please...${nc}"
    echo ""

    mr_description="<h2>Release $release</h2>$html_tickets_list<br><b>$firm</b>"

    git checkout $branch_source
    git pull origin $branch_source

    # Update changelog
    adv_cr_update_changelog
    git add .
    git commit -m "docs: update $file"
    git push origin $branch_source

    git checkout -b $release $branch_source
    git push --set-upstream origin $release

    git commit --allow-empty -m "chore: $tickets"

    echo ""
    echo -e "Creating MR: $mr_title"
    mr_response=$(git push \
        -o merge_request.create \
        -o merge_request.target="$branch_target" \
        -o merge_request.title="$mr_title" \
        -o merge_request.description="$mr_description" \
        -o merge_request.label="AWT Release" \
        2>&1)

    # Get MR URL & ID and open it
    mr_response=$(sed 's/remote://g' <<<"$mr_response")
    mr_response=$(grep 'https://gitlab.com' <<<"$mr_response")
    mr_response=$(sed 's/ *$//g' <<<"$mr_response")

    python -mwebbrowser $mr_response

    echo -e "${color}All operations are done !${nc}"
    echo ""

    exit 0
}

get_tickets_from_release() {
    wellcome

    available_release=$(grep -F '## Release v2' $file | awk -F ":" '{print "\"" $0 "\""}')

    echo "---> $available_release"

    choice_menu "Select a release" "$available_release"

    # Insert release
    last_release="v20220402_1130"
    read -p "$sp - Release: " -e -i $last_release release

    end="## Release"
    tickets=$(sed -n "/$release/,/$end/{ /$start/! {/$end/! p } }" $file)

    echo "$release"
    echo "$tickets"
}

if [ -d .git ]; then
    main
else

    clear
    wellcome
    echo -e "$sp${color}This script must be run in a git repository.${nc}"
    echo ""
    exit 1
fi
